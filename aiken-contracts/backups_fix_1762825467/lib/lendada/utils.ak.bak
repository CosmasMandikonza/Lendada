use aiken/list
use aiken/interval.{Finite, Interval, IntervalBound}
use aiken/transaction.{Output, OutputReference, Transaction}
use aiken/transaction/value.{Value, lovelace_of}

pub fn calculate_interest(principal: Int, rate_bp: Int, duration_days: Int) -> Int {
  principal * rate_bp * duration_days / 365 / 10000
}

pub fn total_repayment(principal: Int, interest: Int) -> Int {
  principal + interest
}

pub fn ms_to_days(ms: Int) -> Int {
  ms / 86400000
}

pub fn is_valid_time_range(
  validity_range: Interval<Int>,
  target_time: Int,
) -> Bool {
  when validity_range.lower_bound.bound_type is {
    Finite(lower) -> lower <= target_time
    _ -> False
  }
}

pub fn is_overdue(current_time: Int, due_at: Int) -> Bool {
  current_time > due_at
}

pub fn has_min_ada(output_value: Value, min_lovelace: Int) -> Bool {
  lovelace_of(output_value) >= min_lovelace
}

# NOTE: compile-first: skip inspecting payment_credential for now.
# You can reintroduce a proper Credential pattern later.
pub fn pays_to_pkh(
  outputs: List<Output>,
  _pkh: ByteArray,
  min_amount: Int,
) -> Bool {
  list.any(
    outputs,
    fn(o) { lovelace_of(o.value) >= min_amount },
  )
}
